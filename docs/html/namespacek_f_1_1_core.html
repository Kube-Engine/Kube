<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kube Framework: kF::Core Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="kube.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kube Framework
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">The next generation game engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacek_f.html">kF</a></li><li class="navelem"><a class="el" href="namespacek_f_1_1_core.html">Core</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">kF::Core Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacek_f_1_1_core_1_1_internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core_1_1_internal.html">Internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacek_f_1_1_core_1_1_utils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core_1_1_utils.html">Utils</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classk_f_1_1_core_1_1_dispatcher_details.html">DispatcherDetails</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classk_f_1_1_core_1_1_dispatcher_details_3_01_return_07_args_8_8_8_08_00_01_cache_size_00_01_template_functor_01_4.html">DispatcherDetails&lt; Return(Args...), CacheSize, TemplateFunctor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast event dispatcher.  <a href="classk_f_1_1_core_1_1_dispatcher_details_3_01_return_07_args_8_8_8_08_00_01_cache_size_00_01_template_functor_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classk_f_1_1_core_1_1_functor.html">Functor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classk_f_1_1_core_1_1_functor_3_01_return_07_args_8_8_8_08_00_01_cache_size_01_4.html">Functor&lt; Return(Args...), CacheSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Very fast opaque functor but only takes trivial types less or equal sized than cacheline eighth.  <a href="classk_f_1_1_core_1_1_functor_3_01_return_07_args_8_8_8_08_00_01_cache_size_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classk_f_1_1_core_1_1_heap_array.html">HeapArray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classk_f_1_1_core_1_1_m_p_m_c_queue.html">MPMCQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MPMC queue is a lock-free queue that only supports a Single Producer but Multiple Consumers.  <a href="classk_f_1_1_core_1_1_m_p_m_c_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classk_f_1_1_core_1_1_s_p_s_c_queue.html">SPSCQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SPSC queue is a lock-free queue that only supports a Single Producer and a Single Consumer The queue is really fast compared to other more flexible implementations because the fact that only two thread can simultaneously read / write means that less synchronization is needed for each operation. The queue supports ranged push / pop to insert multiple elements without performance impact.  <a href="classk_f_1_1_core_1_1_s_p_s_c_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classk_f_1_1_core_1_1_trivial_functor.html">TrivialFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classk_f_1_1_core_1_1_trivial_functor_3_01_return_07_args_8_8_8_08_00_01_cache_size_01_4.html">TrivialFunctor&lt; Return(Args...), CacheSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Very fast opaque functor but only takes trivial types less or equal sized than cacheline eighth.  <a href="classk_f_1_1_core_1_1_trivial_functor_3_01_return_07_args_8_8_8_08_00_01_cache_size_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a97cfe138ca5885b7348f0f6f3a6cc8a4"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto AllocateFunc, auto DeallocateFunc, std::integral Range = std::size_t&gt; </td></tr>
<tr class="memitem:a97cfe138ca5885b7348f0f6f3a6cc8a4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a97cfe138ca5885b7348f0f6f3a6cc8a4">AllocatedFlatStringBase</a> = <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_string_details.html">Internal::StringDetails</a>&lt; <a class="el" href="namespacek_f_1_1_core.html#a12de8ce24a8396324a46bf9fe5db0c51">AllocatedFlatVector</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, AllocateFunc, DeallocateFunc, Range &gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range &gt;</td></tr>
<tr class="memdesc:a97cfe138ca5885b7348f0f6f3a6cc8a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 bytes vector that allocates its size and capacity on the heap The string is non-null terminated The string must take an allocator and a deallocator functor  <a href="namespacek_f_1_1_core.html#a97cfe138ca5885b7348f0f6f3a6cc8a4">More...</a><br /></td></tr>
<tr class="separator:a97cfe138ca5885b7348f0f6f3a6cc8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bb2e6ee1d5de03492baa02b4805581"><td class="memTemplParams" colspan="2">template&lt;auto AllocateFunc, auto DeallocateFunc&gt; </td></tr>
<tr class="memitem:a63bb2e6ee1d5de03492baa02b4805581"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a63bb2e6ee1d5de03492baa02b4805581">AllocatedFlatString</a> = <a class="el" href="namespacek_f_1_1_core.html#a97cfe138ca5885b7348f0f6f3a6cc8a4">AllocatedFlatStringBase</a>&lt; char, AllocateFunc, DeallocateFunc, std::size_t &gt;</td></tr>
<tr class="memdesc:a63bb2e6ee1d5de03492baa02b4805581"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 bytes string using signed char and size_t range The string is non-null terminated The string must take an allocator and a deallocator functor  <a href="namespacek_f_1_1_core.html#a63bb2e6ee1d5de03492baa02b4805581">More...</a><br /></td></tr>
<tr class="separator:a63bb2e6ee1d5de03492baa02b4805581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98189209bf825328ce1b7905c80555fb"><td class="memTemplParams" colspan="2">template&lt;auto AllocateFunc, auto DeallocateFunc&gt; </td></tr>
<tr class="memitem:a98189209bf825328ce1b7905c80555fb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a98189209bf825328ce1b7905c80555fb">AllocatedTinyFlatString</a> = <a class="el" href="namespacek_f_1_1_core.html#a97cfe138ca5885b7348f0f6f3a6cc8a4">AllocatedFlatStringBase</a>&lt; char, AllocateFunc, DeallocateFunc, std::uint32_t &gt;</td></tr>
<tr class="memdesc:a98189209bf825328ce1b7905c80555fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 bytes string using signed char with a reduced range The string is non-null terminated The string must take an allocator and a deallocator functor  <a href="namespacek_f_1_1_core.html#a98189209bf825328ce1b7905c80555fb">More...</a><br /></td></tr>
<tr class="separator:a98189209bf825328ce1b7905c80555fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12de8ce24a8396324a46bf9fe5db0c51"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto AllocateFunc, auto DeallocateFunc, std::integral Range = std::size_t&gt; </td></tr>
<tr class="memitem:a12de8ce24a8396324a46bf9fe5db0c51"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a12de8ce24a8396324a46bf9fe5db0c51">AllocatedFlatVector</a> = <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_vector_details.html">Internal::VectorDetails</a>&lt; <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_allocated_flat_vector_base.html">Internal::AllocatedFlatVectorBase</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, AllocateFunc, DeallocateFunc &gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range &gt;</td></tr>
<tr class="memdesc:a12de8ce24a8396324a46bf9fe5db0c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 bytes vector that allocates its size and capacity on the heap The vector must take an allocator and a deallocator functor  <a href="namespacek_f_1_1_core.html#a12de8ce24a8396324a46bf9fe5db0c51">More...</a><br /></td></tr>
<tr class="separator:a12de8ce24a8396324a46bf9fe5db0c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6a5e2ae9a3a69e46ffe2a8cd1776da"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto AllocateFunc, auto DeallocateFunc&gt; </td></tr>
<tr class="memitem:aea6a5e2ae9a3a69e46ffe2a8cd1776da"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#aea6a5e2ae9a3a69e46ffe2a8cd1776da">AllocatedTinyFlatVector</a> = <a class="el" href="namespacek_f_1_1_core.html#a12de8ce24a8396324a46bf9fe5db0c51">AllocatedFlatVector</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, AllocateFunc, DeallocateFunc, std::uint32_t &gt;</td></tr>
<tr class="memdesc:aea6a5e2ae9a3a69e46ffe2a8cd1776da"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 bytes vector using signed char with a reduced range The vector must take an allocator and a deallocator functor  <a href="namespacek_f_1_1_core.html#aea6a5e2ae9a3a69e46ffe2a8cd1776da">More...</a><br /></td></tr>
<tr class="separator:aea6a5e2ae9a3a69e46ffe2a8cd1776da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f863353b36c1fa1fc2581995fb1ae1"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t OptimizedCapacity, auto AllocateFunc, auto DeallocateFunc, std::integral Range = std::size_t&gt; </td></tr>
<tr class="memitem:ac3f863353b36c1fa1fc2581995fb1ae1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#ac3f863353b36c1fa1fc2581995fb1ae1">AllocatedSmallStringBase</a> = <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_string_details.html">Internal::StringDetails</a>&lt; <a class="el" href="namespacek_f_1_1_core.html#a3a034302506ea04126325184782373e6">AllocatedSmallVector</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, AllocateFunc, DeallocateFunc, Range &gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range &gt;</td></tr>
<tr class="memdesc:ac3f863353b36c1fa1fc2581995fb1ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">String that has its size, capacity and a small cache close to the data pointer The string is non-null terminated The string must take an allocator and a deallocator functor.  <a href="namespacek_f_1_1_core.html#ac3f863353b36c1fa1fc2581995fb1ae1">More...</a><br /></td></tr>
<tr class="separator:ac3f863353b36c1fa1fc2581995fb1ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0b910dced332632068b6060e866ed0"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t OptimizedCapacity, auto AllocateFunc, auto DeallocateFunc&gt; </td></tr>
<tr class="memitem:aea0b910dced332632068b6060e866ed0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#aea0b910dced332632068b6060e866ed0">AllocatedTinySmallStringBase</a> = <a class="el" href="namespacek_f_1_1_core.html#ac3f863353b36c1fa1fc2581995fb1ae1">AllocatedSmallStringBase</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, AllocateFunc, DeallocateFunc, std::uint32_t &gt;</td></tr>
<tr class="memdesc:aea0b910dced332632068b6060e866ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small optimized string with a reduced range The string is non-null terminated The string must take an allocator and a deallocator functor.  <a href="namespacek_f_1_1_core.html#aea0b910dced332632068b6060e866ed0">More...</a><br /></td></tr>
<tr class="separator:aea0b910dced332632068b6060e866ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a2ac3890558735215fcbc860724784"><td class="memTemplParams" colspan="2">template&lt;auto AllocateFunc, auto DeallocateFunc&gt; </td></tr>
<tr class="memitem:a98a2ac3890558735215fcbc860724784"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a98a2ac3890558735215fcbc860724784">AllocatedSmallString</a> = <a class="el" href="namespacek_f_1_1_core.html#ac3f863353b36c1fa1fc2581995fb1ae1">AllocatedSmallStringBase</a>&lt; char, <a class="el" href="namespacek_f_1_1_core.html#a3737452225c53c00a3dc3932a009e952">CacheLineEighthSize</a>, AllocateFunc, DeallocateFunc, std::size_t &gt;</td></tr>
<tr class="memdesc:a98a2ac3890558735215fcbc860724784"><td class="mdescLeft">&#160;</td><td class="mdescRight">32 bytes small optimized string (cache of 8 bytes) The string is non-null terminated The string must take an allocator and a deallocator functor  <a href="namespacek_f_1_1_core.html#a98a2ac3890558735215fcbc860724784">More...</a><br /></td></tr>
<tr class="separator:a98a2ac3890558735215fcbc860724784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7547a542ede3e1032b93903f6f2053d"><td class="memTemplParams" colspan="2">template&lt;auto AllocateFunc, auto DeallocateFunc&gt; </td></tr>
<tr class="memitem:aa7547a542ede3e1032b93903f6f2053d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#aa7547a542ede3e1032b93903f6f2053d">AllocatedTinySmallString</a> = <a class="el" href="namespacek_f_1_1_core.html#aea0b910dced332632068b6060e866ed0">AllocatedTinySmallStringBase</a>&lt; char, <a class="el" href="namespacek_f_1_1_core.html#a82f6b45cdffb871a4b53b279cb67fd5c">CacheLineQuarterSize</a>, AllocateFunc, DeallocateFunc &gt;</td></tr>
<tr class="memdesc:aa7547a542ede3e1032b93903f6f2053d"><td class="mdescLeft">&#160;</td><td class="mdescRight">32 bytes small optimized string (cache of 16 bytes) with a reduced range The string is non-null terminated The string must take an allocator and a deallocator functor  <a href="namespacek_f_1_1_core.html#aa7547a542ede3e1032b93903f6f2053d">More...</a><br /></td></tr>
<tr class="separator:aa7547a542ede3e1032b93903f6f2053d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a034302506ea04126325184782373e6"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t OptimizedCapacity, auto AllocateFunc, auto DeallocateFunc, std::integral Range = std::size_t&gt; </td></tr>
<tr class="memitem:a3a034302506ea04126325184782373e6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a3a034302506ea04126325184782373e6">AllocatedSmallVector</a> = <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_vector_details.html">Internal::VectorDetails</a>&lt; <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_allocated_small_vector_base.html">Internal::AllocatedSmallVectorBase</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, AllocateFunc, DeallocateFunc, Range &gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, <a class="el" href="_s_p_s_c_queue_8ipp.html#a930920b2bc42824a5c03be681830f4b2">true</a> &gt;</td></tr>
<tr class="memdesc:a3a034302506ea04126325184782373e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector that has its size, capacity and a small cache close to the data pointer The vector must take an allocator and a deallocator functor.  <a href="namespacek_f_1_1_core.html#a3a034302506ea04126325184782373e6">More...</a><br /></td></tr>
<tr class="separator:a3a034302506ea04126325184782373e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b2fa8958efee5996c310b24653c662"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t OptimizedCapacity, auto AllocateFunc, auto DeallocateFunc&gt; </td></tr>
<tr class="memitem:a36b2fa8958efee5996c310b24653c662"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a36b2fa8958efee5996c310b24653c662">AllocatedTinySmallVector</a> = <a class="el" href="namespacek_f_1_1_core.html#a3a034302506ea04126325184782373e6">AllocatedSmallVector</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, AllocateFunc, DeallocateFunc, std::uint32_t &gt;</td></tr>
<tr class="memdesc:a36b2fa8958efee5996c310b24653c662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small optimized vector with a reduced range The vector must take an allocator and a deallocator functor.  <a href="namespacek_f_1_1_core.html#a36b2fa8958efee5996c310b24653c662">More...</a><br /></td></tr>
<tr class="separator:a36b2fa8958efee5996c310b24653c662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee9b1eb25a550edac0b9c10811c994d"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto AllocateFunc, auto DeallocateFunc, std::integral Range = std::size_t&gt; </td></tr>
<tr class="memitem:a0ee9b1eb25a550edac0b9c10811c994d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a0ee9b1eb25a550edac0b9c10811c994d">AllocatedStringBase</a> = <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_string_details.html">Internal::StringDetails</a>&lt; <a class="el" href="namespacek_f_1_1_core.html#a871bc78ce110157ca20fc4cccc5c4a27">AllocatedVector</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, AllocateFunc, DeallocateFunc, Range &gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range &gt;</td></tr>
<tr class="memdesc:a0ee9b1eb25a550edac0b9c10811c994d"><td class="mdescLeft">&#160;</td><td class="mdescRight">String that has its size, capacity and a small cache close to the data pointer The string is non-null terminated The string must take an allocator and a deallocator functor.  <a href="namespacek_f_1_1_core.html#a0ee9b1eb25a550edac0b9c10811c994d">More...</a><br /></td></tr>
<tr class="separator:a0ee9b1eb25a550edac0b9c10811c994d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac960d04c3763f400e870a8e6796b720f"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto AllocateFunc, auto DeallocateFunc&gt; </td></tr>
<tr class="memitem:ac960d04c3763f400e870a8e6796b720f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#ac960d04c3763f400e870a8e6796b720f">AllocatedTinyStringBase</a> = <a class="el" href="namespacek_f_1_1_core.html#a0ee9b1eb25a550edac0b9c10811c994d">AllocatedStringBase</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, AllocateFunc, DeallocateFunc, std::uint32_t &gt;</td></tr>
<tr class="memdesc:ac960d04c3763f400e870a8e6796b720f"><td class="mdescLeft">&#160;</td><td class="mdescRight">16 bytes String with a reduced range The string is non-null terminated The string must take an allocator and a deallocator functor  <a href="namespacek_f_1_1_core.html#ac960d04c3763f400e870a8e6796b720f">More...</a><br /></td></tr>
<tr class="separator:ac960d04c3763f400e870a8e6796b720f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484ea81896183b1ffea440bcfa1f2a73"><td class="memTemplParams" colspan="2">template&lt;auto AllocateFunc, auto DeallocateFunc&gt; </td></tr>
<tr class="memitem:a484ea81896183b1ffea440bcfa1f2a73"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a484ea81896183b1ffea440bcfa1f2a73">AllocatedString</a> = <a class="el" href="namespacek_f_1_1_core.html#a0ee9b1eb25a550edac0b9c10811c994d">AllocatedStringBase</a>&lt; char, AllocateFunc, DeallocateFunc, std::size_t &gt;</td></tr>
<tr class="memdesc:a484ea81896183b1ffea440bcfa1f2a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">24 bytes string The string is non-null terminated The string must take an allocator and a deallocator functor  <a href="namespacek_f_1_1_core.html#a484ea81896183b1ffea440bcfa1f2a73">More...</a><br /></td></tr>
<tr class="separator:a484ea81896183b1ffea440bcfa1f2a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15206cd1515bfaa88076f791053f41e"><td class="memTemplParams" colspan="2">template&lt;auto AllocateFunc, auto DeallocateFunc&gt; </td></tr>
<tr class="memitem:ac15206cd1515bfaa88076f791053f41e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#ac15206cd1515bfaa88076f791053f41e">AllocatedTinyString</a> = <a class="el" href="namespacek_f_1_1_core.html#ac960d04c3763f400e870a8e6796b720f">AllocatedTinyStringBase</a>&lt; char, AllocateFunc, DeallocateFunc &gt;</td></tr>
<tr class="memdesc:ac15206cd1515bfaa88076f791053f41e"><td class="mdescLeft">&#160;</td><td class="mdescRight">16 bytes string with a reduced range The string is non-null terminated The string must take an allocator and a deallocator functor  <a href="namespacek_f_1_1_core.html#ac15206cd1515bfaa88076f791053f41e">More...</a><br /></td></tr>
<tr class="separator:ac15206cd1515bfaa88076f791053f41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871bc78ce110157ca20fc4cccc5c4a27"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto AllocateFunc, auto DeallocateFunc, std::integral Range = std::size_t&gt; </td></tr>
<tr class="memitem:a871bc78ce110157ca20fc4cccc5c4a27"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a871bc78ce110157ca20fc4cccc5c4a27">AllocatedVector</a> = <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_vector_details.html">Internal::VectorDetails</a>&lt; <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_allocated_vector_base.html">Internal::AllocatedVectorBase</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, AllocateFunc, DeallocateFunc &gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range &gt;</td></tr>
<tr class="memdesc:a871bc78ce110157ca20fc4cccc5c4a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector that has its size and capacity close to the data pointer With default range (std::size_t), the vector takes 24 bytes The vector must take an allocator and a deallocator functor.  <a href="namespacek_f_1_1_core.html#a871bc78ce110157ca20fc4cccc5c4a27">More...</a><br /></td></tr>
<tr class="separator:a871bc78ce110157ca20fc4cccc5c4a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1089aee11ddcf7200743aaa46303d08"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto AllocateFunc, auto DeallocateFunc&gt; </td></tr>
<tr class="memitem:af1089aee11ddcf7200743aaa46303d08"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#af1089aee11ddcf7200743aaa46303d08">AllocatedTinyVector</a> = <a class="el" href="namespacek_f_1_1_core.html#a5a34083f574656e84e168943e48ddcd6">Vector</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, std::uint32_t &gt;</td></tr>
<tr class="memdesc:af1089aee11ddcf7200743aaa46303d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">16 bytes vector with a reduced range The vector must take an allocator and a deallocator functor  <a href="namespacek_f_1_1_core.html#af1089aee11ddcf7200743aaa46303d08">More...</a><br /></td></tr>
<tr class="separator:af1089aee11ddcf7200743aaa46303d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244fb0432908602d5ab4f7d03bda32ab"><td class="memTemplParams" colspan="2">template&lt;typename Signature , std::size_t CacheSize = CacheLineQuarterSize&gt; </td></tr>
<tr class="memitem:a244fb0432908602d5ab4f7d03bda32ab"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a244fb0432908602d5ab4f7d03bda32ab">Dispatcher</a> = <a class="el" href="classk_f_1_1_core_1_1_dispatcher_details.html">DispatcherDetails</a>&lt; Signature, CacheSize, <a class="el" href="classk_f_1_1_core_1_1_functor.html">Functor</a> &gt;</td></tr>
<tr class="memdesc:a244fb0432908602d5ab4f7d03bda32ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of dispatcher with trivial functors.  <a href="namespacek_f_1_1_core.html#a244fb0432908602d5ab4f7d03bda32ab">More...</a><br /></td></tr>
<tr class="separator:a244fb0432908602d5ab4f7d03bda32ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c5a4218b93b5ff78e6fb766056ee8f"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::integral Range = std::size_t&gt; </td></tr>
<tr class="memitem:af5c5a4218b93b5ff78e6fb766056ee8f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#af5c5a4218b93b5ff78e6fb766056ee8f">FlatStringBase</a> = <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_string_details.html">Internal::StringDetails</a>&lt; <a class="el" href="namespacek_f_1_1_core.html#a301d08d1cc73382fcecd499df46b58a1">FlatVector</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range &gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range &gt;</td></tr>
<tr class="memdesc:af5c5a4218b93b5ff78e6fb766056ee8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 bytes vector that allocates its size and capacity on the heap The string is non-null terminated  <a href="namespacek_f_1_1_core.html#af5c5a4218b93b5ff78e6fb766056ee8f">More...</a><br /></td></tr>
<tr class="separator:af5c5a4218b93b5ff78e6fb766056ee8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add655c2b8906beafd62a7efd317e182d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#add655c2b8906beafd62a7efd317e182d">FlatString</a> = <a class="el" href="namespacek_f_1_1_core.html#af5c5a4218b93b5ff78e6fb766056ee8f">FlatStringBase</a>&lt; char, std::size_t &gt;</td></tr>
<tr class="memdesc:add655c2b8906beafd62a7efd317e182d"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 bytes string using signed char and size_t range The string is non-null terminated  <a href="namespacek_f_1_1_core.html#add655c2b8906beafd62a7efd317e182d">More...</a><br /></td></tr>
<tr class="separator:add655c2b8906beafd62a7efd317e182d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed470f91c055859e8aadf7873ee86507"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#aed470f91c055859e8aadf7873ee86507">TinyFlatString</a> = <a class="el" href="namespacek_f_1_1_core.html#af5c5a4218b93b5ff78e6fb766056ee8f">FlatStringBase</a>&lt; char, std::uint32_t &gt;</td></tr>
<tr class="memdesc:aed470f91c055859e8aadf7873ee86507"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 bytes string using signed char with a reduced range The string is non-null terminated  <a href="namespacek_f_1_1_core.html#aed470f91c055859e8aadf7873ee86507">More...</a><br /></td></tr>
<tr class="separator:aed470f91c055859e8aadf7873ee86507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301d08d1cc73382fcecd499df46b58a1"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::integral Range = std::size_t&gt; </td></tr>
<tr class="memitem:a301d08d1cc73382fcecd499df46b58a1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a301d08d1cc73382fcecd499df46b58a1">FlatVector</a> = <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_vector_details.html">Internal::VectorDetails</a>&lt; <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_flat_vector_base.html">Internal::FlatVectorBase</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range &gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range &gt;</td></tr>
<tr class="memdesc:a301d08d1cc73382fcecd499df46b58a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 bytes vector that allocates its size and capacity on the heap  <a href="namespacek_f_1_1_core.html#a301d08d1cc73382fcecd499df46b58a1">More...</a><br /></td></tr>
<tr class="separator:a301d08d1cc73382fcecd499df46b58a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369cc7880dba7794da862cd1b66531cc"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a369cc7880dba7794da862cd1b66531cc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a369cc7880dba7794da862cd1b66531cc">TinyFlatVector</a> = <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_vector_details.html">Internal::VectorDetails</a>&lt; <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_flat_vector_base.html">Internal::FlatVectorBase</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, std::uint32_t &gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, std::uint32_t &gt;</td></tr>
<tr class="memdesc:a369cc7880dba7794da862cd1b66531cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 bytes vector using signed char with a reduced range  <a href="namespacek_f_1_1_core.html#a369cc7880dba7794da862cd1b66531cc">More...</a><br /></td></tr>
<tr class="separator:a369cc7880dba7794da862cd1b66531cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac349e835df77701db708973bd48cfa94"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t OptimizedCapacity, std::integral Range = std::size_t&gt; </td></tr>
<tr class="memitem:ac349e835df77701db708973bd48cfa94"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#ac349e835df77701db708973bd48cfa94">SmallStringBase</a> = <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_string_details.html">Internal::StringDetails</a>&lt; <a class="el" href="namespacek_f_1_1_core.html#a0a3542d788593e97956f44550001f0bc">SmallVector</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, Range &gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range &gt;</td></tr>
<tr class="memdesc:ac349e835df77701db708973bd48cfa94"><td class="mdescLeft">&#160;</td><td class="mdescRight">String that has its size, capacity and a small cache close to the data pointer The string is non-null terminated.  <a href="namespacek_f_1_1_core.html#ac349e835df77701db708973bd48cfa94">More...</a><br /></td></tr>
<tr class="separator:ac349e835df77701db708973bd48cfa94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4de30a2b4d11c42a6e9a9ec55544aea"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t OptimizedCapacity&gt; </td></tr>
<tr class="memitem:ae4de30a2b4d11c42a6e9a9ec55544aea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#ae4de30a2b4d11c42a6e9a9ec55544aea">TinySmallStringBase</a> = <a class="el" href="namespacek_f_1_1_core.html#a0a3542d788593e97956f44550001f0bc">SmallVector</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, std::uint32_t &gt;</td></tr>
<tr class="memdesc:ae4de30a2b4d11c42a6e9a9ec55544aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small optimized string with a reduced range The string is non-null terminated.  <a href="namespacek_f_1_1_core.html#ae4de30a2b4d11c42a6e9a9ec55544aea">More...</a><br /></td></tr>
<tr class="separator:ae4de30a2b4d11c42a6e9a9ec55544aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35706fc0f34b14c1a6b3687e086f5ba5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a35706fc0f34b14c1a6b3687e086f5ba5">SmallString</a> = <a class="el" href="namespacek_f_1_1_core.html#ac349e835df77701db708973bd48cfa94">SmallStringBase</a>&lt; char, <a class="el" href="namespacek_f_1_1_core.html#a3737452225c53c00a3dc3932a009e952">CacheLineEighthSize</a>, std::size_t &gt;</td></tr>
<tr class="memdesc:a35706fc0f34b14c1a6b3687e086f5ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">32 bytes small optimized string (cache of 8 bytes) The string is non-null terminated  <a href="namespacek_f_1_1_core.html#a35706fc0f34b14c1a6b3687e086f5ba5">More...</a><br /></td></tr>
<tr class="separator:a35706fc0f34b14c1a6b3687e086f5ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5513c19298d552839cc1943f57b144"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#ace5513c19298d552839cc1943f57b144">TinySmallString</a> = <a class="el" href="namespacek_f_1_1_core.html#ae4de30a2b4d11c42a6e9a9ec55544aea">TinySmallStringBase</a>&lt; char, <a class="el" href="namespacek_f_1_1_core.html#a82f6b45cdffb871a4b53b279cb67fd5c">CacheLineQuarterSize</a> &gt;</td></tr>
<tr class="memdesc:ace5513c19298d552839cc1943f57b144"><td class="mdescLeft">&#160;</td><td class="mdescRight">32 bytes small optimized string (cache of 16 bytes) with a reduced range The string is non-null terminated  <a href="namespacek_f_1_1_core.html#ace5513c19298d552839cc1943f57b144">More...</a><br /></td></tr>
<tr class="separator:ace5513c19298d552839cc1943f57b144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3542d788593e97956f44550001f0bc"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t OptimizedCapacity, std::integral Range = std::size_t&gt; </td></tr>
<tr class="memitem:a0a3542d788593e97956f44550001f0bc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a0a3542d788593e97956f44550001f0bc">SmallVector</a> = <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_vector_details.html">Internal::VectorDetails</a>&lt; <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_small_vector_base.html">Internal::SmallVectorBase</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, Range &gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, <a class="el" href="_s_p_s_c_queue_8ipp.html#a930920b2bc42824a5c03be681830f4b2">true</a> &gt;</td></tr>
<tr class="memdesc:a0a3542d788593e97956f44550001f0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector that has its size, capacity and a small cache close to the data pointer.  <a href="namespacek_f_1_1_core.html#a0a3542d788593e97956f44550001f0bc">More...</a><br /></td></tr>
<tr class="separator:a0a3542d788593e97956f44550001f0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492bd9e9a0db0fa9247ea76ebe4de4b7"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t OptimizedCapacity&gt; </td></tr>
<tr class="memitem:a492bd9e9a0db0fa9247ea76ebe4de4b7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a492bd9e9a0db0fa9247ea76ebe4de4b7">TinySmallVector</a> = <a class="el" href="namespacek_f_1_1_core.html#a0a3542d788593e97956f44550001f0bc">SmallVector</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, std::uint32_t &gt;</td></tr>
<tr class="memdesc:a492bd9e9a0db0fa9247ea76ebe4de4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small optimized vector with a reduced range.  <a href="namespacek_f_1_1_core.html#a492bd9e9a0db0fa9247ea76ebe4de4b7">More...</a><br /></td></tr>
<tr class="separator:a492bd9e9a0db0fa9247ea76ebe4de4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bbecb820e5bdb0c690f8043eea9ecf"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto AllocateFunc, auto DeallocateFunc, std::integral Range = std::size_t, typename Compare  = std::less&lt;Type&gt;&gt; </td></tr>
<tr class="memitem:a22bbecb820e5bdb0c690f8043eea9ecf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a22bbecb820e5bdb0c690f8043eea9ecf">SortedAllocatedFlatVector</a> = <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_sorted_vector_details.html">Internal::SortedVectorDetails</a>&lt; <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_allocated_flat_vector_base.html">Internal::AllocatedFlatVectorBase</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, AllocateFunc, DeallocateFunc &gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, Compare &gt;</td></tr>
<tr class="memdesc:a22bbecb820e5bdb0c690f8043eea9ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 bytes vector that allocates its size and capacity on the heap The vector guarantee that it will be sorted at any given time The vector must take an allocator and a deallocator functor  <a href="namespacek_f_1_1_core.html#a22bbecb820e5bdb0c690f8043eea9ecf">More...</a><br /></td></tr>
<tr class="separator:a22bbecb820e5bdb0c690f8043eea9ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0245adb4a1745d61e753dc4f5fe1ca9"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto AllocateFunc, auto DeallocateFunc, typename Compare  = std::less&lt;Type&gt;&gt; </td></tr>
<tr class="memitem:af0245adb4a1745d61e753dc4f5fe1ca9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#af0245adb4a1745d61e753dc4f5fe1ca9">SortedAllocatedTinyFlatVector</a> = <a class="el" href="namespacek_f_1_1_core.html#a22bbecb820e5bdb0c690f8043eea9ecf">SortedAllocatedFlatVector</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, AllocateFunc, DeallocateFunc, std::uint32_t, Compare &gt;</td></tr>
<tr class="memdesc:af0245adb4a1745d61e753dc4f5fe1ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 bytes vector using signed char with a reduced range The vector guarantee that it will be sorted at any given time The vector must take an allocator and a deallocator functor  <a href="namespacek_f_1_1_core.html#af0245adb4a1745d61e753dc4f5fe1ca9">More...</a><br /></td></tr>
<tr class="separator:af0245adb4a1745d61e753dc4f5fe1ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6712c52c2190eabcf1389128c1437d2d"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t OptimizedCapacity, auto AllocateFunc, auto DeallocateFunc, std::integral Range = std::size_t, typename Compare  = std::less&lt;Type&gt;&gt; </td></tr>
<tr class="memitem:a6712c52c2190eabcf1389128c1437d2d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a6712c52c2190eabcf1389128c1437d2d">SortedAllocatedSmallVector</a> = <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_sorted_vector_details.html">Internal::SortedVectorDetails</a>&lt; <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_allocated_small_vector_base.html">Internal::AllocatedSmallVectorBase</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, AllocateFunc, DeallocateFunc, Range &gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, Compare, <a class="el" href="_s_p_s_c_queue_8ipp.html#a930920b2bc42824a5c03be681830f4b2">true</a> &gt;</td></tr>
<tr class="memdesc:a6712c52c2190eabcf1389128c1437d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector that has its size, capacity and a small cache close to the data pointer The vector guarantee that it will be sorted at any given time The vector must take an allocator and a deallocator functor.  <a href="namespacek_f_1_1_core.html#a6712c52c2190eabcf1389128c1437d2d">More...</a><br /></td></tr>
<tr class="separator:a6712c52c2190eabcf1389128c1437d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0eb5f0e2428f0ec3f9c62b790fde5af"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t OptimizedCapacity, auto AllocateFunc, auto DeallocateFunc, typename Compare  = std::less&lt;Type&gt;&gt; </td></tr>
<tr class="memitem:ae0eb5f0e2428f0ec3f9c62b790fde5af"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#ae0eb5f0e2428f0ec3f9c62b790fde5af">SortedAllocatedTinySmallVector</a> = <a class="el" href="namespacek_f_1_1_core.html#a6712c52c2190eabcf1389128c1437d2d">SortedAllocatedSmallVector</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, AllocateFunc, DeallocateFunc, std::uint32_t, Compare &gt;</td></tr>
<tr class="memdesc:ae0eb5f0e2428f0ec3f9c62b790fde5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small optimized vector with a reduced range The vector guarantee that it will be sorted at any given time The vector must take an allocator and a deallocator functor.  <a href="namespacek_f_1_1_core.html#ae0eb5f0e2428f0ec3f9c62b790fde5af">More...</a><br /></td></tr>
<tr class="separator:ae0eb5f0e2428f0ec3f9c62b790fde5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa366db7ce42c4be8651a49971c99a1b7"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto AllocateFunc, auto DeallocateFunc, std::integral Range = std::size_t, typename Compare  = std::less&lt;Type&gt;&gt; </td></tr>
<tr class="memitem:aa366db7ce42c4be8651a49971c99a1b7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#aa366db7ce42c4be8651a49971c99a1b7">SortedAllocatedVector</a> = <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_sorted_vector_details.html">Internal::SortedVectorDetails</a>&lt; <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_allocated_vector_base.html">Internal::AllocatedVectorBase</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, AllocateFunc, DeallocateFunc &gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, Compare &gt;</td></tr>
<tr class="memdesc:aa366db7ce42c4be8651a49971c99a1b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector that has its size and capacity close to the data pointer With default range (std::size_t), the vector takes 24 bytes The vector guarantee that it will be sorted at any given time The vector must take an allocator and a deallocator functor.  <a href="namespacek_f_1_1_core.html#aa366db7ce42c4be8651a49971c99a1b7">More...</a><br /></td></tr>
<tr class="separator:aa366db7ce42c4be8651a49971c99a1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7763ef0b0b70d6da970f8124d8927b"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto AllocateFunc, auto DeallocateFunc, typename Compare  = std::less&lt;Type&gt;&gt; </td></tr>
<tr class="memitem:a2a7763ef0b0b70d6da970f8124d8927b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a2a7763ef0b0b70d6da970f8124d8927b">SortedAllocatedTinyVector</a> = <a class="el" href="namespacek_f_1_1_core.html#aa366db7ce42c4be8651a49971c99a1b7">SortedAllocatedVector</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, AllocateFunc, DeallocateFunc, std::uint32_t, Compare &gt;</td></tr>
<tr class="memdesc:a2a7763ef0b0b70d6da970f8124d8927b"><td class="mdescLeft">&#160;</td><td class="mdescRight">16 bytes vector with a reduced range The vector guarantee that it will be sorted at any given time The vector must take an allocator and a deallocator functor  <a href="namespacek_f_1_1_core.html#a2a7763ef0b0b70d6da970f8124d8927b">More...</a><br /></td></tr>
<tr class="separator:a2a7763ef0b0b70d6da970f8124d8927b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187021a3073707e705800f9bf41d192b"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::integral Range = std::size_t, typename Compare  = std::less&lt;Type&gt;&gt; </td></tr>
<tr class="memitem:a187021a3073707e705800f9bf41d192b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a187021a3073707e705800f9bf41d192b">SortedFlatVector</a> = <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_sorted_vector_details.html">Internal::SortedVectorDetails</a>&lt; <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_flat_vector_base.html">Internal::FlatVectorBase</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range &gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, Compare &gt;</td></tr>
<tr class="memdesc:a187021a3073707e705800f9bf41d192b"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 bytes vector that allocates its size and capacity on the heap The vector guarantee that it will be sorted at any given time  <a href="namespacek_f_1_1_core.html#a187021a3073707e705800f9bf41d192b">More...</a><br /></td></tr>
<tr class="separator:a187021a3073707e705800f9bf41d192b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38df1cbee5f11530875724f383ed15e7"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Compare  = std::less&lt;Type&gt;&gt; </td></tr>
<tr class="memitem:a38df1cbee5f11530875724f383ed15e7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a38df1cbee5f11530875724f383ed15e7">SortedTinyFlatVector</a> = <a class="el" href="namespacek_f_1_1_core.html#a187021a3073707e705800f9bf41d192b">SortedFlatVector</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, std::uint32_t, Compare &gt;</td></tr>
<tr class="memdesc:a38df1cbee5f11530875724f383ed15e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 bytes vector using signed char with a reduced range The vector guarantee that it will be sorted at any given time  <a href="namespacek_f_1_1_core.html#a38df1cbee5f11530875724f383ed15e7">More...</a><br /></td></tr>
<tr class="separator:a38df1cbee5f11530875724f383ed15e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2545bf104317cf4c0cc0eec735d4ba8f"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t OptimizedCapacity, std::integral Range = std::size_t, typename Compare  = std::less&lt;Type&gt;&gt; </td></tr>
<tr class="memitem:a2545bf104317cf4c0cc0eec735d4ba8f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a2545bf104317cf4c0cc0eec735d4ba8f">SortedSmallVector</a> = <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_sorted_vector_details.html">Internal::SortedVectorDetails</a>&lt; <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_small_vector_base.html">Internal::SmallVectorBase</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, Range &gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, Compare, <a class="el" href="_s_p_s_c_queue_8ipp.html#a930920b2bc42824a5c03be681830f4b2">true</a> &gt;</td></tr>
<tr class="memdesc:a2545bf104317cf4c0cc0eec735d4ba8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector that has its size, capacity and a small cache close to the data pointer The vector guarantee that it will be sorted at any given time.  <a href="namespacek_f_1_1_core.html#a2545bf104317cf4c0cc0eec735d4ba8f">More...</a><br /></td></tr>
<tr class="separator:a2545bf104317cf4c0cc0eec735d4ba8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf18cff6e761a027d99fcbf47f017b6"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t OptimizedCapacity, typename Compare  = std::less&lt;Type&gt;&gt; </td></tr>
<tr class="memitem:acdf18cff6e761a027d99fcbf47f017b6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#acdf18cff6e761a027d99fcbf47f017b6">SortedTinySmallVector</a> = <a class="el" href="namespacek_f_1_1_core.html#a2545bf104317cf4c0cc0eec735d4ba8f">SortedSmallVector</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, std::uint32_t, Compare &gt;</td></tr>
<tr class="memdesc:acdf18cff6e761a027d99fcbf47f017b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small optimized vector with a reduced range The vector guarantee that it will be sorted at any given time.  <a href="namespacek_f_1_1_core.html#acdf18cff6e761a027d99fcbf47f017b6">More...</a><br /></td></tr>
<tr class="separator:acdf18cff6e761a027d99fcbf47f017b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a150c19fa10df80a89445118b5fca18"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::integral Range = std::size_t, typename Compare  = std::less&lt;Type&gt;&gt; </td></tr>
<tr class="memitem:a5a150c19fa10df80a89445118b5fca18"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a5a150c19fa10df80a89445118b5fca18">SortedVector</a> = <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_sorted_vector_details.html">Internal::SortedVectorDetails</a>&lt; <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_vector_base.html">Internal::VectorBase</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range &gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, Compare &gt;</td></tr>
<tr class="memdesc:a5a150c19fa10df80a89445118b5fca18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector that has its size and capacity close to the data pointer With default range (std::size_t), the vector takes 24 bytes The vector guarantee that it will be sorted at any given time.  <a href="namespacek_f_1_1_core.html#a5a150c19fa10df80a89445118b5fca18">More...</a><br /></td></tr>
<tr class="separator:a5a150c19fa10df80a89445118b5fca18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4e10fdf1d95e98085d52c078654516"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Compare  = std::less&lt;Type&gt;&gt; </td></tr>
<tr class="memitem:ace4e10fdf1d95e98085d52c078654516"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#ace4e10fdf1d95e98085d52c078654516">SortedTinyVector</a> = <a class="el" href="namespacek_f_1_1_core.html#a5a150c19fa10df80a89445118b5fca18">SortedVector</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, std::uint32_t, Compare &gt;</td></tr>
<tr class="memdesc:ace4e10fdf1d95e98085d52c078654516"><td class="mdescLeft">&#160;</td><td class="mdescRight">16 bytes vector with a reduced range The vector guarantee that it will be sorted at any given time  <a href="namespacek_f_1_1_core.html#ace4e10fdf1d95e98085d52c078654516">More...</a><br /></td></tr>
<tr class="separator:ace4e10fdf1d95e98085d52c078654516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074c73500607e25e08dd798f447e1af9"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::integral Range = std::size_t&gt; </td></tr>
<tr class="memitem:a074c73500607e25e08dd798f447e1af9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a074c73500607e25e08dd798f447e1af9">StringBase</a> = <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_string_details.html">Internal::StringDetails</a>&lt; <a class="el" href="namespacek_f_1_1_core.html#a5a34083f574656e84e168943e48ddcd6">Vector</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range &gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range &gt;</td></tr>
<tr class="memdesc:a074c73500607e25e08dd798f447e1af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">String that has its size and capacity close to the data pointer The string is non-null terminated.  <a href="namespacek_f_1_1_core.html#a074c73500607e25e08dd798f447e1af9">More...</a><br /></td></tr>
<tr class="separator:a074c73500607e25e08dd798f447e1af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ec1cd44d09b016d9928b688e58fe71"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ac2ec1cd44d09b016d9928b688e58fe71"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#ac2ec1cd44d09b016d9928b688e58fe71">TinyStringBase</a> = <a class="el" href="namespacek_f_1_1_core.html#a074c73500607e25e08dd798f447e1af9">StringBase</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, std::uint32_t &gt;</td></tr>
<tr class="memdesc:ac2ec1cd44d09b016d9928b688e58fe71"><td class="mdescLeft">&#160;</td><td class="mdescRight">16 bytes string with a reduced range The string is non-null terminated  <a href="namespacek_f_1_1_core.html#ac2ec1cd44d09b016d9928b688e58fe71">More...</a><br /></td></tr>
<tr class="separator:ac2ec1cd44d09b016d9928b688e58fe71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7601c7d7ff316dccc5ae14d7134ad10"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#aa7601c7d7ff316dccc5ae14d7134ad10">String</a> = <a class="el" href="namespacek_f_1_1_core.html#a074c73500607e25e08dd798f447e1af9">StringBase</a>&lt; char, std::size_t &gt;</td></tr>
<tr class="memdesc:aa7601c7d7ff316dccc5ae14d7134ad10"><td class="mdescLeft">&#160;</td><td class="mdescRight">24 bytes string using signed char The string is non-null terminated  <a href="namespacek_f_1_1_core.html#aa7601c7d7ff316dccc5ae14d7134ad10">More...</a><br /></td></tr>
<tr class="separator:aa7601c7d7ff316dccc5ae14d7134ad10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fef719112e39ca7728610d49e31050"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a32fef719112e39ca7728610d49e31050">TinyString</a> = <a class="el" href="namespacek_f_1_1_core.html#ac2ec1cd44d09b016d9928b688e58fe71">TinyStringBase</a>&lt; char &gt;</td></tr>
<tr class="memdesc:a32fef719112e39ca7728610d49e31050"><td class="mdescLeft">&#160;</td><td class="mdescRight">16 bytes string using signed char with a reduced range The string is non-null terminated  <a href="namespacek_f_1_1_core.html#a32fef719112e39ca7728610d49e31050">More...</a><br /></td></tr>
<tr class="separator:a32fef719112e39ca7728610d49e31050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87463c4c51236e14eb4caf724d46e98"><td class="memTemplParams" colspan="2">template&lt;typename Signature , std::size_t CacheSize = CacheLineEighthSize&gt; </td></tr>
<tr class="memitem:ab87463c4c51236e14eb4caf724d46e98"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#ab87463c4c51236e14eb4caf724d46e98">TrivialDispatcher</a> = <a class="el" href="classk_f_1_1_core_1_1_dispatcher_details.html">DispatcherDetails</a>&lt; Signature, CacheSize, <a class="el" href="classk_f_1_1_core_1_1_trivial_functor.html">TrivialFunctor</a> &gt;</td></tr>
<tr class="memdesc:ab87463c4c51236e14eb4caf724d46e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of dispatcher with trivial functors.  <a href="namespacek_f_1_1_core.html#ab87463c4c51236e14eb4caf724d46e98">More...</a><br /></td></tr>
<tr class="separator:ab87463c4c51236e14eb4caf724d46e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a34083f574656e84e168943e48ddcd6"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::integral Range = std::size_t&gt; </td></tr>
<tr class="memitem:a5a34083f574656e84e168943e48ddcd6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a5a34083f574656e84e168943e48ddcd6">Vector</a> = <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_vector_details.html">Internal::VectorDetails</a>&lt; <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_vector_base.html">Internal::VectorBase</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range &gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range &gt;</td></tr>
<tr class="memdesc:a5a34083f574656e84e168943e48ddcd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector that has its size and capacity close to the data pointer With default range (std::size_t), the vector takes 24 bytes.  <a href="namespacek_f_1_1_core.html#a5a34083f574656e84e168943e48ddcd6">More...</a><br /></td></tr>
<tr class="separator:a5a34083f574656e84e168943e48ddcd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afb4d5554aba95a7ec6819977b10abc"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a9afb4d5554aba95a7ec6819977b10abc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a9afb4d5554aba95a7ec6819977b10abc">TinyVector</a> = <a class="el" href="namespacek_f_1_1_core.html#a5a34083f574656e84e168943e48ddcd6">Vector</a>&lt; <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, std::uint32_t &gt;</td></tr>
<tr class="memdesc:a9afb4d5554aba95a7ec6819977b10abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">16 bytes vector with a reduced range  <a href="namespacek_f_1_1_core.html#a9afb4d5554aba95a7ec6819977b10abc">More...</a><br /></td></tr>
<tr class="separator:a9afb4d5554aba95a7ec6819977b10abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa1f35d7f50ec7928ea8e42e01493e2e1"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#aa1f35d7f50ec7928ea8e42e01493e2e1">CacheLineSize</a> = sizeof(std::size_t) * 8</td></tr>
<tr class="memdesc:aa1f35d7f50ec7928ea8e42e01493e2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Theorical cacheline size.  <a href="namespacek_f_1_1_core.html#aa1f35d7f50ec7928ea8e42e01493e2e1">More...</a><br /></td></tr>
<tr class="separator:aa1f35d7f50ec7928ea8e42e01493e2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5b5db4b3b817aaab1aea3c64523dd5"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#abb5b5db4b3b817aaab1aea3c64523dd5">CacheLineDoubleSize</a> = <a class="el" href="namespacek_f_1_1_core.html#aa1f35d7f50ec7928ea8e42e01493e2e1">CacheLineSize</a> * 2</td></tr>
<tr class="separator:abb5b5db4b3b817aaab1aea3c64523dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc49a6577816ab36a507d1b268b83df"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a8dc49a6577816ab36a507d1b268b83df">CacheLineHalfSize</a> = <a class="el" href="namespacek_f_1_1_core.html#aa1f35d7f50ec7928ea8e42e01493e2e1">CacheLineSize</a> / 2</td></tr>
<tr class="separator:a8dc49a6577816ab36a507d1b268b83df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f6b45cdffb871a4b53b279cb67fd5c"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a82f6b45cdffb871a4b53b279cb67fd5c">CacheLineQuarterSize</a> = <a class="el" href="namespacek_f_1_1_core.html#aa1f35d7f50ec7928ea8e42e01493e2e1">CacheLineSize</a> / 4</td></tr>
<tr class="separator:a82f6b45cdffb871a4b53b279cb67fd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3737452225c53c00a3dc3932a009e952"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacek_f_1_1_core.html#a3737452225c53c00a3dc3932a009e952">CacheLineEighthSize</a> = <a class="el" href="namespacek_f_1_1_core.html#aa1f35d7f50ec7928ea8e42e01493e2e1">CacheLineSize</a> / 8</td></tr>
<tr class="separator:a3737452225c53c00a3dc3932a009e952"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>@ Author: Matthieu Moinvaziri @ Description: FlatVector</p>
<p>@ Author: Matthieu Moinvaziri @ Description: Small Vector</p>
<p>@ Author: Matthieu Moinvaziri @ Description: Vector</p>
<p>@ Author: Matthieu Moinvaziri @ Description: Trivial dispatcher</p>
<p>@ Author: Matthieu Moinvaziri @ Description: Dispatcher</p>
<p>@ Author: Matthieu Moinvaziri @ Description: FlatString</p>
<p>@ Author: Matthieu Moinvaziri @ Description: <a class="el" href="classk_f_1_1_core_1_1_functor.html">Functor</a></p>
<p>@ Author: Matthieu Moinvaziri @ Description: A dead simple runtime array</p>
<p>@ Author: Matthieu Moinvaziri @ Description: MPMC Queue</p>
<p>@ Author: Matthieu Moinvaziri @ Description: Small String</p>
<p>@ Author: Matthieu Moinvaziri @ Description: Sorted FlatVector</p>
<p>@ Author: Matthieu Moinvaziri @ Description: Sorted SmallVector</p>
<p>@ Author: Matthieu Moinvaziri @ Description: Sorted Vector</p>
<p>@ Author: Matthieu Moinvaziri @ Description: SPSC Queue</p>
<p>@ Author: Matthieu Moinvaziri @ Description: String</p>
<p>@ Author: Matthieu Moinvaziri @ Description: Trivial opaque functor holder </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a63bb2e6ee1d5de03492baa02b4805581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63bb2e6ee1d5de03492baa02b4805581">&#9670;&nbsp;</a></span>AllocatedFlatString</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto AllocateFunc, auto DeallocateFunc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a63bb2e6ee1d5de03492baa02b4805581">kF::Core::AllocatedFlatString</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#a97cfe138ca5885b7348f0f6f3a6cc8a4">AllocatedFlatStringBase</a>&lt;char, AllocateFunc, DeallocateFunc, std::size_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>8 bytes string using signed char and size_t range The string is non-null terminated The string must take an allocator and a deallocator functor </p>

</div>
</div>
<a id="a97cfe138ca5885b7348f0f6f3a6cc8a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97cfe138ca5885b7348f0f6f3a6cc8a4">&#9670;&nbsp;</a></span>AllocatedFlatStringBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto AllocateFunc, auto DeallocateFunc, std::integral Range = std::size_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a97cfe138ca5885b7348f0f6f3a6cc8a4">kF::Core::AllocatedFlatStringBase</a> = typedef <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_string_details.html">Internal::StringDetails</a>&lt;<a class="el" href="namespacek_f_1_1_core.html#a12de8ce24a8396324a46bf9fe5db0c51">AllocatedFlatVector</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, AllocateFunc, DeallocateFunc, Range&gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>8 bytes vector that allocates its size and capacity on the heap The string is non-null terminated The string must take an allocator and a deallocator functor </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td><a class="el" href="namespacek_f_1_1_core_1_1_internal.html">Internal</a> type in container </td></tr>
    <tr><td class="paramname">AllocateFunc</td><td>Allocator </td></tr>
    <tr><td class="paramname">DeallocateFunc</td><td>Deallocator </td></tr>
    <tr><td class="paramname">Range</td><td>Range of container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12de8ce24a8396324a46bf9fe5db0c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12de8ce24a8396324a46bf9fe5db0c51">&#9670;&nbsp;</a></span>AllocatedFlatVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto AllocateFunc, auto DeallocateFunc, std::integral Range = std::size_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a12de8ce24a8396324a46bf9fe5db0c51">kF::Core::AllocatedFlatVector</a> = typedef <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_vector_details.html">Internal::VectorDetails</a>&lt;<a class="el" href="classk_f_1_1_core_1_1_internal_1_1_allocated_flat_vector_base.html">Internal::AllocatedFlatVectorBase</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, AllocateFunc, DeallocateFunc&gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>8 bytes vector that allocates its size and capacity on the heap The vector must take an allocator and a deallocator functor </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td><a class="el" href="namespacek_f_1_1_core_1_1_internal.html">Internal</a> type in container </td></tr>
    <tr><td class="paramname">AllocateFunc</td><td>Allocator </td></tr>
    <tr><td class="paramname">DeallocateFunc</td><td>Deallocator </td></tr>
    <tr><td class="paramname">Range</td><td>Range of container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98a2ac3890558735215fcbc860724784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a2ac3890558735215fcbc860724784">&#9670;&nbsp;</a></span>AllocatedSmallString</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto AllocateFunc, auto DeallocateFunc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a98a2ac3890558735215fcbc860724784">kF::Core::AllocatedSmallString</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#ac3f863353b36c1fa1fc2581995fb1ae1">AllocatedSmallStringBase</a>&lt;char, <a class="el" href="namespacek_f_1_1_core.html#a3737452225c53c00a3dc3932a009e952">CacheLineEighthSize</a>, AllocateFunc, DeallocateFunc, std::size_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>32 bytes small optimized string (cache of 8 bytes) The string is non-null terminated The string must take an allocator and a deallocator functor </p>

</div>
</div>
<a id="ac3f863353b36c1fa1fc2581995fb1ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f863353b36c1fa1fc2581995fb1ae1">&#9670;&nbsp;</a></span>AllocatedSmallStringBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t OptimizedCapacity, auto AllocateFunc, auto DeallocateFunc, std::integral Range = std::size_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#ac3f863353b36c1fa1fc2581995fb1ae1">kF::Core::AllocatedSmallStringBase</a> = typedef <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_string_details.html">Internal::StringDetails</a>&lt;<a class="el" href="namespacek_f_1_1_core.html#a3a034302506ea04126325184782373e6">AllocatedSmallVector</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, AllocateFunc, DeallocateFunc, Range&gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>String that has its size, capacity and a small cache close to the data pointer The string is non-null terminated The string must take an allocator and a deallocator functor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of character </td></tr>
    <tr><td class="paramname">OptimizedCapacity</td><td>Count of element in the optimized cache </td></tr>
    <tr><td class="paramname">AllocateFunc</td><td>Allocator </td></tr>
    <tr><td class="paramname">DeallocateFunc</td><td>Deallocator </td></tr>
    <tr><td class="paramname">Range</td><td>Range of container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a034302506ea04126325184782373e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a034302506ea04126325184782373e6">&#9670;&nbsp;</a></span>AllocatedSmallVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t OptimizedCapacity, auto AllocateFunc, auto DeallocateFunc, std::integral Range = std::size_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a3a034302506ea04126325184782373e6">kF::Core::AllocatedSmallVector</a> = typedef <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_vector_details.html">Internal::VectorDetails</a>&lt;<a class="el" href="classk_f_1_1_core_1_1_internal_1_1_allocated_small_vector_base.html">Internal::AllocatedSmallVectorBase</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, AllocateFunc, DeallocateFunc, Range&gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, <a class="el" href="_s_p_s_c_queue_8ipp.html#a930920b2bc42824a5c03be681830f4b2">true</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector that has its size, capacity and a small cache close to the data pointer The vector must take an allocator and a deallocator functor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td><a class="el" href="namespacek_f_1_1_core_1_1_internal.html">Internal</a> type in container </td></tr>
    <tr><td class="paramname">OptimizedCapacity</td><td>Count of element in the optimized cache </td></tr>
    <tr><td class="paramname">AllocateFunc</td><td>Allocator </td></tr>
    <tr><td class="paramname">DeallocateFunc</td><td>Deallocator </td></tr>
    <tr><td class="paramname">Range</td><td>Range of container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a484ea81896183b1ffea440bcfa1f2a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484ea81896183b1ffea440bcfa1f2a73">&#9670;&nbsp;</a></span>AllocatedString</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto AllocateFunc, auto DeallocateFunc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a484ea81896183b1ffea440bcfa1f2a73">kF::Core::AllocatedString</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#a0ee9b1eb25a550edac0b9c10811c994d">AllocatedStringBase</a>&lt;char, AllocateFunc, DeallocateFunc, std::size_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>24 bytes string The string is non-null terminated The string must take an allocator and a deallocator functor </p>

</div>
</div>
<a id="a0ee9b1eb25a550edac0b9c10811c994d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee9b1eb25a550edac0b9c10811c994d">&#9670;&nbsp;</a></span>AllocatedStringBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto AllocateFunc, auto DeallocateFunc, std::integral Range = std::size_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a0ee9b1eb25a550edac0b9c10811c994d">kF::Core::AllocatedStringBase</a> = typedef <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_string_details.html">Internal::StringDetails</a>&lt;<a class="el" href="namespacek_f_1_1_core.html#a871bc78ce110157ca20fc4cccc5c4a27">AllocatedVector</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, AllocateFunc, DeallocateFunc, Range&gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>String that has its size, capacity and a small cache close to the data pointer The string is non-null terminated The string must take an allocator and a deallocator functor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of character </td></tr>
    <tr><td class="paramname">AllocateFunc</td><td>Allocator </td></tr>
    <tr><td class="paramname">DeallocateFunc</td><td>Deallocator </td></tr>
    <tr><td class="paramname">Range</td><td>Range of container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98189209bf825328ce1b7905c80555fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98189209bf825328ce1b7905c80555fb">&#9670;&nbsp;</a></span>AllocatedTinyFlatString</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto AllocateFunc, auto DeallocateFunc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a98189209bf825328ce1b7905c80555fb">kF::Core::AllocatedTinyFlatString</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#a97cfe138ca5885b7348f0f6f3a6cc8a4">AllocatedFlatStringBase</a>&lt;char, AllocateFunc, DeallocateFunc, std::uint32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>8 bytes string using signed char with a reduced range The string is non-null terminated The string must take an allocator and a deallocator functor </p>

</div>
</div>
<a id="aea6a5e2ae9a3a69e46ffe2a8cd1776da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6a5e2ae9a3a69e46ffe2a8cd1776da">&#9670;&nbsp;</a></span>AllocatedTinyFlatVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto AllocateFunc, auto DeallocateFunc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#aea6a5e2ae9a3a69e46ffe2a8cd1776da">kF::Core::AllocatedTinyFlatVector</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#a12de8ce24a8396324a46bf9fe5db0c51">AllocatedFlatVector</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, AllocateFunc, DeallocateFunc, std::uint32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>8 bytes vector using signed char with a reduced range The vector must take an allocator and a deallocator functor </p>

</div>
</div>
<a id="aa7547a542ede3e1032b93903f6f2053d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7547a542ede3e1032b93903f6f2053d">&#9670;&nbsp;</a></span>AllocatedTinySmallString</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto AllocateFunc, auto DeallocateFunc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#aa7547a542ede3e1032b93903f6f2053d">kF::Core::AllocatedTinySmallString</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#aea0b910dced332632068b6060e866ed0">AllocatedTinySmallStringBase</a>&lt;char, <a class="el" href="namespacek_f_1_1_core.html#a82f6b45cdffb871a4b53b279cb67fd5c">CacheLineQuarterSize</a>, AllocateFunc, DeallocateFunc&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>32 bytes small optimized string (cache of 16 bytes) with a reduced range The string is non-null terminated The string must take an allocator and a deallocator functor </p>

</div>
</div>
<a id="aea0b910dced332632068b6060e866ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0b910dced332632068b6060e866ed0">&#9670;&nbsp;</a></span>AllocatedTinySmallStringBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t OptimizedCapacity, auto AllocateFunc, auto DeallocateFunc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#aea0b910dced332632068b6060e866ed0">kF::Core::AllocatedTinySmallStringBase</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#ac3f863353b36c1fa1fc2581995fb1ae1">AllocatedSmallStringBase</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, AllocateFunc, DeallocateFunc, std::uint32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Small optimized string with a reduced range The string is non-null terminated The string must take an allocator and a deallocator functor. </p>

</div>
</div>
<a id="a36b2fa8958efee5996c310b24653c662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b2fa8958efee5996c310b24653c662">&#9670;&nbsp;</a></span>AllocatedTinySmallVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t OptimizedCapacity, auto AllocateFunc, auto DeallocateFunc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a36b2fa8958efee5996c310b24653c662">kF::Core::AllocatedTinySmallVector</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#a3a034302506ea04126325184782373e6">AllocatedSmallVector</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, AllocateFunc, DeallocateFunc, std::uint32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Small optimized vector with a reduced range The vector must take an allocator and a deallocator functor. </p>

</div>
</div>
<a id="ac15206cd1515bfaa88076f791053f41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15206cd1515bfaa88076f791053f41e">&#9670;&nbsp;</a></span>AllocatedTinyString</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto AllocateFunc, auto DeallocateFunc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#ac15206cd1515bfaa88076f791053f41e">kF::Core::AllocatedTinyString</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#ac960d04c3763f400e870a8e6796b720f">AllocatedTinyStringBase</a>&lt;char, AllocateFunc, DeallocateFunc&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>16 bytes string with a reduced range The string is non-null terminated The string must take an allocator and a deallocator functor </p>

</div>
</div>
<a id="ac960d04c3763f400e870a8e6796b720f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac960d04c3763f400e870a8e6796b720f">&#9670;&nbsp;</a></span>AllocatedTinyStringBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto AllocateFunc, auto DeallocateFunc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#ac960d04c3763f400e870a8e6796b720f">kF::Core::AllocatedTinyStringBase</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#a0ee9b1eb25a550edac0b9c10811c994d">AllocatedStringBase</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, AllocateFunc, DeallocateFunc, std::uint32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>16 bytes String with a reduced range The string is non-null terminated The string must take an allocator and a deallocator functor </p>

</div>
</div>
<a id="af1089aee11ddcf7200743aaa46303d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1089aee11ddcf7200743aaa46303d08">&#9670;&nbsp;</a></span>AllocatedTinyVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto AllocateFunc, auto DeallocateFunc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#af1089aee11ddcf7200743aaa46303d08">kF::Core::AllocatedTinyVector</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#a5a34083f574656e84e168943e48ddcd6">Vector</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, std::uint32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>16 bytes vector with a reduced range The vector must take an allocator and a deallocator functor </p>

</div>
</div>
<a id="a871bc78ce110157ca20fc4cccc5c4a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871bc78ce110157ca20fc4cccc5c4a27">&#9670;&nbsp;</a></span>AllocatedVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto AllocateFunc, auto DeallocateFunc, std::integral Range = std::size_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a871bc78ce110157ca20fc4cccc5c4a27">kF::Core::AllocatedVector</a> = typedef <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_vector_details.html">Internal::VectorDetails</a>&lt;<a class="el" href="classk_f_1_1_core_1_1_internal_1_1_allocated_vector_base.html">Internal::AllocatedVectorBase</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, AllocateFunc, DeallocateFunc&gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector that has its size and capacity close to the data pointer With default range (std::size_t), the vector takes 24 bytes The vector must take an allocator and a deallocator functor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td><a class="el" href="namespacek_f_1_1_core_1_1_internal.html">Internal</a> type in container </td></tr>
    <tr><td class="paramname">AllocateFunc</td><td>Allocator </td></tr>
    <tr><td class="paramname">DeallocateFunc</td><td>Deallocator </td></tr>
    <tr><td class="paramname">Range</td><td>Range of container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a244fb0432908602d5ab4f7d03bda32ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244fb0432908602d5ab4f7d03bda32ab">&#9670;&nbsp;</a></span>Dispatcher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , std::size_t CacheSize = CacheLineQuarterSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a244fb0432908602d5ab4f7d03bda32ab">kF::Core::Dispatcher</a> = typedef <a class="el" href="classk_f_1_1_core_1_1_dispatcher_details.html">DispatcherDetails</a>&lt;Signature, CacheSize, <a class="el" href="classk_f_1_1_core_1_1_functor.html">Functor</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialization of dispatcher with trivial functors. </p>

</div>
</div>
<a id="add655c2b8906beafd62a7efd317e182d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add655c2b8906beafd62a7efd317e182d">&#9670;&nbsp;</a></span>FlatString</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#add655c2b8906beafd62a7efd317e182d">kF::Core::FlatString</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#af5c5a4218b93b5ff78e6fb766056ee8f">FlatStringBase</a>&lt;char, std::size_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>8 bytes string using signed char and size_t range The string is non-null terminated </p>

</div>
</div>
<a id="af5c5a4218b93b5ff78e6fb766056ee8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c5a4218b93b5ff78e6fb766056ee8f">&#9670;&nbsp;</a></span>FlatStringBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::integral Range = std::size_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#af5c5a4218b93b5ff78e6fb766056ee8f">kF::Core::FlatStringBase</a> = typedef <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_string_details.html">Internal::StringDetails</a>&lt;<a class="el" href="namespacek_f_1_1_core.html#a301d08d1cc73382fcecd499df46b58a1">FlatVector</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range&gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>8 bytes vector that allocates its size and capacity on the heap The string is non-null terminated </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of character </td></tr>
    <tr><td class="paramname">Range</td><td>Range of container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a301d08d1cc73382fcecd499df46b58a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301d08d1cc73382fcecd499df46b58a1">&#9670;&nbsp;</a></span>FlatVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::integral Range = std::size_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a301d08d1cc73382fcecd499df46b58a1">kF::Core::FlatVector</a> = typedef <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_vector_details.html">Internal::VectorDetails</a>&lt;<a class="el" href="classk_f_1_1_core_1_1_internal_1_1_flat_vector_base.html">Internal::FlatVectorBase</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range&gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>8 bytes vector that allocates its size and capacity on the heap </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td><a class="el" href="namespacek_f_1_1_core_1_1_internal.html">Internal</a> type in container </td></tr>
    <tr><td class="paramname">Range</td><td>Range of container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35706fc0f34b14c1a6b3687e086f5ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35706fc0f34b14c1a6b3687e086f5ba5">&#9670;&nbsp;</a></span>SmallString</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a35706fc0f34b14c1a6b3687e086f5ba5">kF::Core::SmallString</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#ac349e835df77701db708973bd48cfa94">SmallStringBase</a>&lt;char, <a class="el" href="namespacek_f_1_1_core.html#a3737452225c53c00a3dc3932a009e952">CacheLineEighthSize</a>, std::size_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>32 bytes small optimized string (cache of 8 bytes) The string is non-null terminated </p>

</div>
</div>
<a id="ac349e835df77701db708973bd48cfa94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac349e835df77701db708973bd48cfa94">&#9670;&nbsp;</a></span>SmallStringBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t OptimizedCapacity, std::integral Range = std::size_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#ac349e835df77701db708973bd48cfa94">kF::Core::SmallStringBase</a> = typedef <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_string_details.html">Internal::StringDetails</a>&lt;<a class="el" href="namespacek_f_1_1_core.html#a0a3542d788593e97956f44550001f0bc">SmallVector</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, Range&gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>String that has its size, capacity and a small cache close to the data pointer The string is non-null terminated. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of character </td></tr>
    <tr><td class="paramname">OptimizedCapacity</td><td>Count of element in the optimized cache </td></tr>
    <tr><td class="paramname">Range</td><td>Range of container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a3542d788593e97956f44550001f0bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3542d788593e97956f44550001f0bc">&#9670;&nbsp;</a></span>SmallVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t OptimizedCapacity, std::integral Range = std::size_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a0a3542d788593e97956f44550001f0bc">kF::Core::SmallVector</a> = typedef <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_vector_details.html">Internal::VectorDetails</a>&lt;<a class="el" href="classk_f_1_1_core_1_1_internal_1_1_small_vector_base.html">Internal::SmallVectorBase</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, Range&gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, <a class="el" href="_s_p_s_c_queue_8ipp.html#a930920b2bc42824a5c03be681830f4b2">true</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector that has its size, capacity and a small cache close to the data pointer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td><a class="el" href="namespacek_f_1_1_core_1_1_internal.html">Internal</a> type in container </td></tr>
    <tr><td class="paramname">OptimizedCapacity</td><td>Count of element in the optimized cache </td></tr>
    <tr><td class="paramname">Range</td><td>Range of container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22bbecb820e5bdb0c690f8043eea9ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bbecb820e5bdb0c690f8043eea9ecf">&#9670;&nbsp;</a></span>SortedAllocatedFlatVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto AllocateFunc, auto DeallocateFunc, std::integral Range = std::size_t, typename Compare  = std::less&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a22bbecb820e5bdb0c690f8043eea9ecf">kF::Core::SortedAllocatedFlatVector</a> = typedef <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_sorted_vector_details.html">Internal::SortedVectorDetails</a>&lt;<a class="el" href="classk_f_1_1_core_1_1_internal_1_1_allocated_flat_vector_base.html">Internal::AllocatedFlatVectorBase</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, AllocateFunc, DeallocateFunc&gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, Compare&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>8 bytes vector that allocates its size and capacity on the heap The vector guarantee that it will be sorted at any given time The vector must take an allocator and a deallocator functor </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td><a class="el" href="namespacek_f_1_1_core_1_1_internal.html">Internal</a> type in container </td></tr>
    <tr><td class="paramname">AllocateFunc</td><td>Allocator </td></tr>
    <tr><td class="paramname">DeallocateFunc</td><td>Deallocator </td></tr>
    <tr><td class="paramname">Range</td><td>Range of container </td></tr>
    <tr><td class="paramname">Compare</td><td>Compare operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6712c52c2190eabcf1389128c1437d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6712c52c2190eabcf1389128c1437d2d">&#9670;&nbsp;</a></span>SortedAllocatedSmallVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t OptimizedCapacity, auto AllocateFunc, auto DeallocateFunc, std::integral Range = std::size_t, typename Compare  = std::less&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a6712c52c2190eabcf1389128c1437d2d">kF::Core::SortedAllocatedSmallVector</a> = typedef <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_sorted_vector_details.html">Internal::SortedVectorDetails</a>&lt;<a class="el" href="classk_f_1_1_core_1_1_internal_1_1_allocated_small_vector_base.html">Internal::AllocatedSmallVectorBase</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, AllocateFunc, DeallocateFunc, Range&gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, Compare, <a class="el" href="_s_p_s_c_queue_8ipp.html#a930920b2bc42824a5c03be681830f4b2">true</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector that has its size, capacity and a small cache close to the data pointer The vector guarantee that it will be sorted at any given time The vector must take an allocator and a deallocator functor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td><a class="el" href="namespacek_f_1_1_core_1_1_internal.html">Internal</a> type in container </td></tr>
    <tr><td class="paramname">OptimizedCapacity</td><td>Count of element in the optimized cache </td></tr>
    <tr><td class="paramname">AllocateFunc</td><td>Allocator </td></tr>
    <tr><td class="paramname">DeallocateFunc</td><td>Deallocator </td></tr>
    <tr><td class="paramname">Range</td><td>Range of container </td></tr>
    <tr><td class="paramname">Compare</td><td>Compare operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0245adb4a1745d61e753dc4f5fe1ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0245adb4a1745d61e753dc4f5fe1ca9">&#9670;&nbsp;</a></span>SortedAllocatedTinyFlatVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto AllocateFunc, auto DeallocateFunc, typename Compare  = std::less&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#af0245adb4a1745d61e753dc4f5fe1ca9">kF::Core::SortedAllocatedTinyFlatVector</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#a22bbecb820e5bdb0c690f8043eea9ecf">SortedAllocatedFlatVector</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, AllocateFunc, DeallocateFunc, std::uint32_t, Compare&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>8 bytes vector using signed char with a reduced range The vector guarantee that it will be sorted at any given time The vector must take an allocator and a deallocator functor </p>

</div>
</div>
<a id="ae0eb5f0e2428f0ec3f9c62b790fde5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0eb5f0e2428f0ec3f9c62b790fde5af">&#9670;&nbsp;</a></span>SortedAllocatedTinySmallVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t OptimizedCapacity, auto AllocateFunc, auto DeallocateFunc, typename Compare  = std::less&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#ae0eb5f0e2428f0ec3f9c62b790fde5af">kF::Core::SortedAllocatedTinySmallVector</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#a6712c52c2190eabcf1389128c1437d2d">SortedAllocatedSmallVector</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, AllocateFunc, DeallocateFunc, std::uint32_t, Compare&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Small optimized vector with a reduced range The vector guarantee that it will be sorted at any given time The vector must take an allocator and a deallocator functor. </p>

</div>
</div>
<a id="a2a7763ef0b0b70d6da970f8124d8927b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7763ef0b0b70d6da970f8124d8927b">&#9670;&nbsp;</a></span>SortedAllocatedTinyVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto AllocateFunc, auto DeallocateFunc, typename Compare  = std::less&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a2a7763ef0b0b70d6da970f8124d8927b">kF::Core::SortedAllocatedTinyVector</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#aa366db7ce42c4be8651a49971c99a1b7">SortedAllocatedVector</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, AllocateFunc, DeallocateFunc, std::uint32_t, Compare&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>16 bytes vector with a reduced range The vector guarantee that it will be sorted at any given time The vector must take an allocator and a deallocator functor </p>

</div>
</div>
<a id="aa366db7ce42c4be8651a49971c99a1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa366db7ce42c4be8651a49971c99a1b7">&#9670;&nbsp;</a></span>SortedAllocatedVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto AllocateFunc, auto DeallocateFunc, std::integral Range = std::size_t, typename Compare  = std::less&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#aa366db7ce42c4be8651a49971c99a1b7">kF::Core::SortedAllocatedVector</a> = typedef <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_sorted_vector_details.html">Internal::SortedVectorDetails</a>&lt;<a class="el" href="classk_f_1_1_core_1_1_internal_1_1_allocated_vector_base.html">Internal::AllocatedVectorBase</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, AllocateFunc, DeallocateFunc&gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, Compare&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector that has its size and capacity close to the data pointer With default range (std::size_t), the vector takes 24 bytes The vector guarantee that it will be sorted at any given time The vector must take an allocator and a deallocator functor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td><a class="el" href="namespacek_f_1_1_core_1_1_internal.html">Internal</a> type in container </td></tr>
    <tr><td class="paramname">AllocateFunc</td><td>Allocator </td></tr>
    <tr><td class="paramname">DeallocateFunc</td><td>Deallocator </td></tr>
    <tr><td class="paramname">Range</td><td>Range of container </td></tr>
    <tr><td class="paramname">Compare</td><td>Compare operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a187021a3073707e705800f9bf41d192b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187021a3073707e705800f9bf41d192b">&#9670;&nbsp;</a></span>SortedFlatVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::integral Range = std::size_t, typename Compare  = std::less&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a187021a3073707e705800f9bf41d192b">kF::Core::SortedFlatVector</a> = typedef <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_sorted_vector_details.html">Internal::SortedVectorDetails</a>&lt;<a class="el" href="classk_f_1_1_core_1_1_internal_1_1_flat_vector_base.html">Internal::FlatVectorBase</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range&gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, Compare&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>8 bytes vector that allocates its size and capacity on the heap The vector guarantee that it will be sorted at any given time </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td><a class="el" href="namespacek_f_1_1_core_1_1_internal.html">Internal</a> type in container </td></tr>
    <tr><td class="paramname">Range</td><td>Range of container </td></tr>
    <tr><td class="paramname">Compare</td><td>Compare operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2545bf104317cf4c0cc0eec735d4ba8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2545bf104317cf4c0cc0eec735d4ba8f">&#9670;&nbsp;</a></span>SortedSmallVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t OptimizedCapacity, std::integral Range = std::size_t, typename Compare  = std::less&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a2545bf104317cf4c0cc0eec735d4ba8f">kF::Core::SortedSmallVector</a> = typedef <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_sorted_vector_details.html">Internal::SortedVectorDetails</a>&lt;<a class="el" href="classk_f_1_1_core_1_1_internal_1_1_small_vector_base.html">Internal::SmallVectorBase</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, Range&gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, Compare, <a class="el" href="_s_p_s_c_queue_8ipp.html#a930920b2bc42824a5c03be681830f4b2">true</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector that has its size, capacity and a small cache close to the data pointer The vector guarantee that it will be sorted at any given time. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td><a class="el" href="namespacek_f_1_1_core_1_1_internal.html">Internal</a> type in container </td></tr>
    <tr><td class="paramname">OptimizedCapacity</td><td>Count of element in the optimized cache </td></tr>
    <tr><td class="paramname">Range</td><td>Range of container </td></tr>
    <tr><td class="paramname">Compare</td><td>Compare operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38df1cbee5f11530875724f383ed15e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38df1cbee5f11530875724f383ed15e7">&#9670;&nbsp;</a></span>SortedTinyFlatVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Compare  = std::less&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a38df1cbee5f11530875724f383ed15e7">kF::Core::SortedTinyFlatVector</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#a187021a3073707e705800f9bf41d192b">SortedFlatVector</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, std::uint32_t, Compare&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>8 bytes vector using signed char with a reduced range The vector guarantee that it will be sorted at any given time </p>

</div>
</div>
<a id="acdf18cff6e761a027d99fcbf47f017b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf18cff6e761a027d99fcbf47f017b6">&#9670;&nbsp;</a></span>SortedTinySmallVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t OptimizedCapacity, typename Compare  = std::less&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#acdf18cff6e761a027d99fcbf47f017b6">kF::Core::SortedTinySmallVector</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#a2545bf104317cf4c0cc0eec735d4ba8f">SortedSmallVector</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, std::uint32_t, Compare&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Small optimized vector with a reduced range The vector guarantee that it will be sorted at any given time. </p>

</div>
</div>
<a id="ace4e10fdf1d95e98085d52c078654516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace4e10fdf1d95e98085d52c078654516">&#9670;&nbsp;</a></span>SortedTinyVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Compare  = std::less&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#ace4e10fdf1d95e98085d52c078654516">kF::Core::SortedTinyVector</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#a5a150c19fa10df80a89445118b5fca18">SortedVector</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, std::uint32_t, Compare&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>16 bytes vector with a reduced range The vector guarantee that it will be sorted at any given time </p>

</div>
</div>
<a id="a5a150c19fa10df80a89445118b5fca18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a150c19fa10df80a89445118b5fca18">&#9670;&nbsp;</a></span>SortedVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::integral Range = std::size_t, typename Compare  = std::less&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a5a150c19fa10df80a89445118b5fca18">kF::Core::SortedVector</a> = typedef <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_sorted_vector_details.html">Internal::SortedVectorDetails</a>&lt;<a class="el" href="classk_f_1_1_core_1_1_internal_1_1_vector_base.html">Internal::VectorBase</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range&gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range, Compare&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector that has its size and capacity close to the data pointer With default range (std::size_t), the vector takes 24 bytes The vector guarantee that it will be sorted at any given time. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td><a class="el" href="namespacek_f_1_1_core_1_1_internal.html">Internal</a> type in container </td></tr>
    <tr><td class="paramname">Range</td><td>Range of container </td></tr>
    <tr><td class="paramname">Compare</td><td>Compare operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7601c7d7ff316dccc5ae14d7134ad10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7601c7d7ff316dccc5ae14d7134ad10">&#9670;&nbsp;</a></span>String</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#aa7601c7d7ff316dccc5ae14d7134ad10">kF::Core::String</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#a074c73500607e25e08dd798f447e1af9">StringBase</a>&lt;char, std::size_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>24 bytes string using signed char The string is non-null terminated </p>

</div>
</div>
<a id="a074c73500607e25e08dd798f447e1af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074c73500607e25e08dd798f447e1af9">&#9670;&nbsp;</a></span>StringBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::integral Range = std::size_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a074c73500607e25e08dd798f447e1af9">kF::Core::StringBase</a> = typedef <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_string_details.html">Internal::StringDetails</a>&lt;<a class="el" href="namespacek_f_1_1_core.html#a5a34083f574656e84e168943e48ddcd6">Vector</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range&gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>String that has its size and capacity close to the data pointer The string is non-null terminated. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of character </td></tr>
    <tr><td class="paramname">Range</td><td>Range of container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed470f91c055859e8aadf7873ee86507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed470f91c055859e8aadf7873ee86507">&#9670;&nbsp;</a></span>TinyFlatString</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#aed470f91c055859e8aadf7873ee86507">kF::Core::TinyFlatString</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#af5c5a4218b93b5ff78e6fb766056ee8f">FlatStringBase</a>&lt;char, std::uint32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>8 bytes string using signed char with a reduced range The string is non-null terminated </p>

</div>
</div>
<a id="a369cc7880dba7794da862cd1b66531cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369cc7880dba7794da862cd1b66531cc">&#9670;&nbsp;</a></span>TinyFlatVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a369cc7880dba7794da862cd1b66531cc">kF::Core::TinyFlatVector</a> = typedef <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_vector_details.html">Internal::VectorDetails</a>&lt;<a class="el" href="classk_f_1_1_core_1_1_internal_1_1_flat_vector_base.html">Internal::FlatVectorBase</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, std::uint32_t&gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, std::uint32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>8 bytes vector using signed char with a reduced range </p>

</div>
</div>
<a id="ace5513c19298d552839cc1943f57b144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5513c19298d552839cc1943f57b144">&#9670;&nbsp;</a></span>TinySmallString</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#ace5513c19298d552839cc1943f57b144">kF::Core::TinySmallString</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#ae4de30a2b4d11c42a6e9a9ec55544aea">TinySmallStringBase</a>&lt;char, <a class="el" href="namespacek_f_1_1_core.html#a82f6b45cdffb871a4b53b279cb67fd5c">CacheLineQuarterSize</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>32 bytes small optimized string (cache of 16 bytes) with a reduced range The string is non-null terminated </p>

</div>
</div>
<a id="ae4de30a2b4d11c42a6e9a9ec55544aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4de30a2b4d11c42a6e9a9ec55544aea">&#9670;&nbsp;</a></span>TinySmallStringBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t OptimizedCapacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#ae4de30a2b4d11c42a6e9a9ec55544aea">kF::Core::TinySmallStringBase</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#a0a3542d788593e97956f44550001f0bc">SmallVector</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, std::uint32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Small optimized string with a reduced range The string is non-null terminated. </p>

</div>
</div>
<a id="a492bd9e9a0db0fa9247ea76ebe4de4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492bd9e9a0db0fa9247ea76ebe4de4b7">&#9670;&nbsp;</a></span>TinySmallVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t OptimizedCapacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a492bd9e9a0db0fa9247ea76ebe4de4b7">kF::Core::TinySmallVector</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#a0a3542d788593e97956f44550001f0bc">SmallVector</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, OptimizedCapacity, std::uint32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Small optimized vector with a reduced range. </p>

</div>
</div>
<a id="a32fef719112e39ca7728610d49e31050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32fef719112e39ca7728610d49e31050">&#9670;&nbsp;</a></span>TinyString</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a32fef719112e39ca7728610d49e31050">kF::Core::TinyString</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#ac2ec1cd44d09b016d9928b688e58fe71">TinyStringBase</a>&lt;char&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>16 bytes string using signed char with a reduced range The string is non-null terminated </p>

</div>
</div>
<a id="ac2ec1cd44d09b016d9928b688e58fe71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ec1cd44d09b016d9928b688e58fe71">&#9670;&nbsp;</a></span>TinyStringBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#ac2ec1cd44d09b016d9928b688e58fe71">kF::Core::TinyStringBase</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#a074c73500607e25e08dd798f447e1af9">StringBase</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, std::uint32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>16 bytes string with a reduced range The string is non-null terminated </p>

</div>
</div>
<a id="a9afb4d5554aba95a7ec6819977b10abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9afb4d5554aba95a7ec6819977b10abc">&#9670;&nbsp;</a></span>TinyVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a9afb4d5554aba95a7ec6819977b10abc">kF::Core::TinyVector</a> = typedef <a class="el" href="namespacek_f_1_1_core.html#a5a34083f574656e84e168943e48ddcd6">Vector</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, std::uint32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>16 bytes vector with a reduced range </p>

</div>
</div>
<a id="ab87463c4c51236e14eb4caf724d46e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87463c4c51236e14eb4caf724d46e98">&#9670;&nbsp;</a></span>TrivialDispatcher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , std::size_t CacheSize = CacheLineEighthSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#ab87463c4c51236e14eb4caf724d46e98">kF::Core::TrivialDispatcher</a> = typedef <a class="el" href="classk_f_1_1_core_1_1_dispatcher_details.html">DispatcherDetails</a>&lt;Signature, CacheSize, <a class="el" href="classk_f_1_1_core_1_1_trivial_functor.html">TrivialFunctor</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialization of dispatcher with trivial functors. </p>

</div>
</div>
<a id="a5a34083f574656e84e168943e48ddcd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a34083f574656e84e168943e48ddcd6">&#9670;&nbsp;</a></span>Vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::integral Range = std::size_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacek_f_1_1_core.html#a5a34083f574656e84e168943e48ddcd6">kF::Core::Vector</a> = typedef <a class="el" href="classk_f_1_1_core_1_1_internal_1_1_vector_details.html">Internal::VectorDetails</a>&lt;<a class="el" href="classk_f_1_1_core_1_1_internal_1_1_vector_base.html">Internal::VectorBase</a>&lt;<a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range&gt;, <a class="el" href="_m_p_m_c_queue_8ipp.html#a781fc8e643f4d363e38b43d82c1862d3">Type</a>, Range&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector that has its size and capacity close to the data pointer With default range (std::size_t), the vector takes 24 bytes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td><a class="el" href="namespacek_f_1_1_core_1_1_internal.html">Internal</a> type in container </td></tr>
    <tr><td class="paramname">Range</td><td>Range of container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="abb5b5db4b3b817aaab1aea3c64523dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5b5db4b3b817aaab1aea3c64523dd5">&#9670;&nbsp;</a></span>CacheLineDoubleSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t kF::Core::CacheLineDoubleSize = <a class="el" href="namespacek_f_1_1_core.html#aa1f35d7f50ec7928ea8e42e01493e2e1">CacheLineSize</a> * 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3737452225c53c00a3dc3932a009e952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3737452225c53c00a3dc3932a009e952">&#9670;&nbsp;</a></span>CacheLineEighthSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t kF::Core::CacheLineEighthSize = <a class="el" href="namespacek_f_1_1_core.html#aa1f35d7f50ec7928ea8e42e01493e2e1">CacheLineSize</a> / 8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8dc49a6577816ab36a507d1b268b83df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc49a6577816ab36a507d1b268b83df">&#9670;&nbsp;</a></span>CacheLineHalfSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t kF::Core::CacheLineHalfSize = <a class="el" href="namespacek_f_1_1_core.html#aa1f35d7f50ec7928ea8e42e01493e2e1">CacheLineSize</a> / 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a82f6b45cdffb871a4b53b279cb67fd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f6b45cdffb871a4b53b279cb67fd5c">&#9670;&nbsp;</a></span>CacheLineQuarterSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t kF::Core::CacheLineQuarterSize = <a class="el" href="namespacek_f_1_1_core.html#aa1f35d7f50ec7928ea8e42e01493e2e1">CacheLineSize</a> / 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1f35d7f50ec7928ea8e42e01493e2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f35d7f50ec7928ea8e42e01493e2e1">&#9670;&nbsp;</a></span>CacheLineSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t kF::Core::CacheLineSize = sizeof(std::size_t) * 8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Theorical cacheline size. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
